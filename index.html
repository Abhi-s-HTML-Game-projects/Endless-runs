<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Temple Run Clone</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: #fff;
      display: none;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="gameOver">Game Over</div>
  
  <!-- Include Three.js from a CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // ----- Scene, Camera, Renderer Setup -----
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.02);
    
    const camera = new THREE.PerspectiveCamera(
      75, 
      window.innerWidth / window.innerHeight, 
      0.1, 
      1000
    );
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    
    // ----- Lighting -----
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(0, 1, 1);
    scene.add(directionalLight);
    
    // ----- Player Setup -----
    const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
    const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
    const player = new THREE.Mesh(playerGeometry, playerMaterial);
    player.position.set(0, 0.5, 0);
    scene.add(player);
    
    // ----- Ground Setup -----
    const groundGeometry = new THREE.PlaneGeometry(10, 2000, 10, 200);
    const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.z = -1000;
    scene.add(ground);
    
    // ----- Lane and Movement Variables -----
    const lanePositions = [-2, 0, 2]; // left, center, right lanes
    let currentLane = 1;             // start at center lane
    let targetX = lanePositions[currentLane];
    const forwardSpeed = 0.2;        // player forward speed
    
    // ----- Obstacles -----
    const obstacles = [];
    
    function createObstacle(zPosition) {
      const lane = lanePositions[Math.floor(Math.random() * lanePositions.length)];
      const obstacleGeometry = new THREE.BoxGeometry(1, 1, 1);
      const obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
      const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
      obstacle.position.set(lane, 0.5, zPosition);
      scene.add(obstacle);
      obstacles.push(obstacle);
    }
    
    // Create initial obstacles with lower density.
    const obstacleSpacing = 40;
    for (let z = -20; z > -1000; z -= obstacleSpacing) {
      // 70% chance to create an obstacle at this spacing
      if (Math.random() < 0.7) {
        createObstacle(z);
      }
    }
    
    // ----- Camera Positioning -----
    camera.position.set(0, 5, 5);
    camera.lookAt(player.position);
    
    // ----- Keyboard Controls (Arrow keys and A/D keys) -----
    window.addEventListener("keydown", (event) => {
      const key = event.key.toLowerCase();
      if ((key === "arrowleft" || key === "a") && currentLane > 0) {
        currentLane--;
        targetX = lanePositions[currentLane];
      }
      if ((key === "arrowright" || key === "d") && currentLane < lanePositions.length - 1) {
        currentLane++;
        targetX = lanePositions[currentLane];
      }
    });
    
    // ----- Improved Collision Detection using Box3 -----
    function detectCollision(obj1, obj2) {
      const box1 = new THREE.Box3().setFromObject(obj1);
      const box2 = new THREE.Box3().setFromObject(obj2);
      return box1.intersectsBox(box2);
    }
    
    // ----- Game Loop -----
    let gameOver = false;
    
    function animate() {
      if (gameOver) return;
      requestAnimationFrame(animate);
      
      // Move player forward continuously
      player.position.z -= forwardSpeed;
      
      // Smoothly transition player to target lane
      player.position.x += (targetX - player.position.x) * 0.2;
      
      // Update camera to follow player
      camera.position.z = player.position.z + 5;
      camera.position.x += (player.position.x - camera.position.x) * 0.1;
      camera.lookAt(player.position);
      
      // Move obstacles and generate new ones when needed
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obs = obstacles[i];
        // When an obstacle is behind the player, remove it...
        if (obs.position.z > player.position.z + 5) {
          scene.remove(obs);
          obstacles.splice(i, 1);
          // Only add a new obstacle with a 50% chance
          if (Math.random() < 0.5) {
            createObstacle(player.position.z - 100);
          }
        }
        // Check collision with player
        if (detectCollision(player, obs)) {
          gameOver = true;
          document.getElementById("gameOver").style.display = "block";
        }
      }
      
      renderer.render(scene, camera);
    }
    
    animate();
    
    // ----- Handle Window Resize -----
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
